# -*- coding: utf-8 -*-
from qm import QuantumMachinesManager
from qm.qua import *
from qm import SimulationConfig
import matplotlib.pyplot as plt
import numpy as np
from pathlib import Path

# 네 프로젝트용 설정 파일
from configuration_odmr_CHJ import *  # NV_IF_freq, NV_LO_freq, long_meas_len_1, wait_between_runs, config, u, save_dir, default_additional_files

from qualang_tools.results import fetching_tool, progress_counter
from qualang_tools.plot import interrupt_on_close
from qualang_tools.results.data_handler import DataHandler

##################
#   Parameters   #
##################
# IF offset 벡터 (기준 IF=40 MHz를 중심으로 ± 스윕)
f_vec = np.arange(-30 * u.MHz, 60 * u.MHz, 0.5 * u.MHz)   # [-20, +59] MHz, 총 80 포인트
n_avg = 5_000  # 테스트는 200~2,000 권장. 필요시 점진 증가
readout_len = long_meas_len_1  # 이미 ns 단위 '정수'임 (u.ns 곱하지 말기)

save_data_dict = {
    "n_avg": n_avg,
    "IF_frequencies": f_vec,
    "config": config,
}

###################
# Galvo parameter #
###################
x_want = 0.1
y_want = 0.1

galvo_ramp_time = 1_000_000 * u.ns // 4
ramp_x_volt = (x_want) / (galvo_ramp_time )
ramp_y_volt = (y_want) / (galvo_ramp_time )

###################
# The QUA program #
###################
with program() as cw_odmr:
    times = declare(int, size=100)
    counts = declare(int)
    counts_st = declare_stream()
    counts_dark_st = declare_stream()
    f = declare(int)     # IF offset (Hz)
    n = declare(int)     # averages
    n_st = declare_stream()

    a = declare(int)
    b = declare(int)

    # (주의) mirror_x/mirror_y 요소는 네 config에 정의돼 있어야 함
    with for_(a, 0, a < 6, a + 1):
        play(ramp(ramp_x_volt/6), "mirror_x", duration=galvo_ramp_time + (a*0))
    with for_(b, 0, b < 6, b + 1):
        play(ramp(ramp_y_volt/6), "mirror_y", duration=galvo_ramp_time + (b*0))

    # 싱글-포인트 ODMR averaging
    with for_(n, 0, n < n_avg, n + 1):
        with for_(*from_array(f, f_vec)):
            # IF = NV_IF_freq + f (음수 IF 방지)
            update_frequency("NV", NV_IF_freq + f)

            align("NV", "AOM1", "SPCM1")

            # ---- MW ON + 레이저 ON ----
            play("cw" * amp(1), "NV", duration=readout_len)
            play("laser_ON", "AOM1", duration=readout_len)
            wait(500 * u.ns, "SPCM1")  # 초기 산란 버리기
            measure("long_readout", "SPCM1",
                    time_tagging.analog(times, readout_len, counts))
            save(counts, counts_st)

            # ---- MW OFF + 레이저 ON ----
            wait(wait_between_runs * u.ns)
            align("NV", "AOM1", "SPCM1")
            play("cw" * amp(0), "NV", duration=readout_len)
            play("laser_ON", "AOM1", duration=readout_len)
            wait(500 * u.ns, "SPCM1")
            measure("long_readout", "SPCM1",
                    time_tagging.analog(times, readout_len, counts))
            save(counts, counts_dark_st)

            wait(wait_between_runs * u.ns)
            save(n, n_st)

    # 원점 복귀
    ramp_to_zero("mirror_x", duration=galvo_ramp_time * 12)
    ramp_to_zero("mirror_y", duration=galvo_ramp_time * 12)

    with stream_processing():
        counts_st.buffer(len(f_vec)).average().save("counts")
        counts_dark_st.buffer(len(f_vec)).average().save("counts_dark")
        n_st.save("iteration")

#####################################
#  Open Communication with the QOP  #
#####################################
qmm = QuantumMachinesManager(host=qop_ip, port=qop_port)

#######################
# Simulate or execute #
#######################
simulate =False

if simulate:
    simulation_config = SimulationConfig(duration=10_000_0)
    job = qmm.simulate(config, cw_odmr, simulation_config)
    samples = job.get_simulated_samples()
    samples.con1.plot()
else:
    qm = qmm.open_qm(config)
    job = qm.execute(cw_odmr)

    results = fetching_tool(job, data_list=["counts", "counts_dark", "iteration"], mode="live")

    fig = plt.figure()
    interrupt_on_close(fig, job)

    while results.is_processing():
        counts, counts_dark, iteration = results.fetch_all()
        progress_counter(iteration, n_avg, start_time=results.get_start_time())

        plt.cla()
        # IF offset(MHz)로 보기
        x_if_mhz = f_vec / u.MHz
        plt.plot(x_if_mhz, counts / (readout_len * 1e-9), label="MW ON (cps)")
        plt.plot(x_if_mhz, counts_dark / (readout_len * 1e-9), label="MW OFF (cps)")

        # 절대 주파수로 보고 싶으면 (upper sideband 가정: LO + IF)
        # x_abs_ghz = (NV_LO_freq + (NV_IF_freq + f_vec)) / 1e9
        # plt.plot(x_abs_ghz, ...)
        contrast = (counts_dark - counts) / counts_dark   # counts_dark=MW OFF, counts=MW ON
        plt.plot(f_vec/u.MHz, 100*contrast)
        plt.xlabel("IF offset [MHz]")
        plt.ylabel("Contrast (%)")
        plt.title("ODMR Contrast")
        plt.show()
        
        # plt.xlabel("IF offset [MHz]")  # 또는 "MW frequency [GHz]"로 바꾸고 x_abs_ghz 사용
        # plt.ylabel("Intensity [cps]")
        # plt.title("ODMR")
        # plt.legend()
        # plt.pause(0.1)

    # 저장
    script_name = Path(__file__).name
    data_handler = DataHandler(root_data_folder=save_dir)
    save_data_dict.update({"counts_data": counts})
    save_data_dict.update({"counts_dark_data": counts_dark})
    save_data_dict.update({"fig_live": fig})
    data_handler.additional_files = {script_name: script_name, **default_additional_files}
    data_handler.save_data(data=save_data_dict, name="_".join(script_name.split("_")[1:]).split(".")[0])
