# -*- coding: utf-8 -*-
"""
Created on Fri Aug  8 19:23:56 2025

@author: user
"""

"""
Galvo mirror raster scan (+ fixed 2.87 GHz RF per pixel)
- 각 픽셀에서 레이저 켜기 직전에 NV에 2.87 GHz RF(CW)를 잠깐 켜서
  측정 구간과 겹치게 함 -> ODMR 감소가 있으면 해당 픽셀 형광이 어두워짐
"""

import datetime
import time
from qm import SimulationConfig, LoopbackInterface
from qm.qua import *
from qm import QuantumMachinesManager
from configuration_odmr_CHJ import *
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np  # <-- np.linspace 사용

#%%
###################
# The QUA program #
###################

plot = True
test = False
simulate = False

#############################################################
# Counter parameters
#############################################################
total_integration_time = int(1000 * u.us) // 4  # Total duration of the measurement
single_integration_time_ns = int(500 * u.us) // 4  # Duration of a single chunk
single_integration_time_cycles = single_integration_time_ns // 4
n_count = int(total_integration_time / single_integration_time_ns)  # # of chunks
count_wait_time = 0.1 * u.ms // 4
integration_time_sec = total_integration_time * 1e-9 * 4

#############################################################
# Galvo mirror parameters
#############################################################
pixel_x = 51   # default 321
pixel_y = 51   # default 321

voltage_x_add = 2 * (-mirror_amp) / ((pixel_x - 1) * mirror_amp)
voltage_y_add = 2 * (-mirror_amp) / ((pixel_y - 1) * mirror_amp)
# 위의 2* scale은 [-mirror_amp, +mirror_amp] 전체 범위 스캔

galvo_ramp_time = 1_000_000 * u.ns // 4  # 1 ms
galvo_x_time = 1 * u.ms // 4 + total_integration_time + 2 * count_wait_time
galvo_y_time = galvo_ramp_time + (galvo_x_time * (pixel_x + 1))
single_galvo_y_time = galvo_y_time

ramp_x_voltage = (mirror_amp) / (galvo_ramp_time * 4)
ramp_y_voltage = (mirror_amp) / (galvo_ramp_time * 4)

laser_cycle = total_integration_time * 1.1
laser_wait_time = count_wait_time
wait_time = 1 * u.us // 4

#############################################################
# Fixed RF at 2.87 GHz (IQ with external LO)
#############################################################
# 외부 VSG LO = NV_LO_freq (galvo_raster_config에서 불러옴)
# 목표 절대 주파수
f_abs_target = int(2.87 * u.GHz)
# OPX가 낼 IF (예: 40 MHz)
F_IF = abs(f_abs_target - NV_LO_freq)

# RF가 측정 구간과 확실히 겹치도록 CW 길이(여유 200 ns)
mw_cw_len = int(count_wait_time + n_count * single_integration_time_ns + 200)

##### end of parameters #####
#############################

with program() as raster_scan:

    v_x = declare(fixed)
    v_y = declare(fixed)

    times = declare(int, size=1000)  # time-tags
    counts = declare(int)            # counts per chunk
    total_counts = declare(int)      # counts per pixel
    n = declare(int)                 # loop counter
    counts_st = declare_stream()     # stream for counts

    a = declare(int)
    b = declare(int)
    n_y = declare(int)
    n_x = declare(int)

    # 1) y ramp to mirror_amp
    with for_(a, 0, a < 6, a + 1):
        play(ramp(ramp_y_voltage / 6), "mirror_y", duration=galvo_ramp_time + (a * 0))

    # 2) Scan rows in Y
    with for_(n_y, 0, n_y < pixel_y, n_y + 1):
        with if_(n_y == 0):
            wait(galvo_y_time + (n_y * 0), "mirror_y")
        with else_():
            play(amp(voltage_y_add) * "const", "mirror_y", duration=galvo_y_time + (n_y * 0))

        # 3) x ramp to mirror_amp after set y voltage
        with for_(b, 0, b < 6, b + 1):
            play(ramp(ramp_x_voltage / 6), "mirror_x", duration=galvo_ramp_time + (b * 0))

        # 4) Scan columns in X
        with for_(n_x, 0, n_x < pixel_x, n_x + 1):
            with if_(n_x == 0):
                wait(galvo_x_time + (n_x * 0), "mirror_x")
            with else_():
                play(amp(voltage_x_add) * "const", "mirror_x", duration=galvo_x_time + (n_x * 0))

            # --- 여기서부터 각 픽셀 측정 ---

            # 레이저/측정과 겹치게 RF를 먼저 켬 (2.87 GHz)
            update_frequency("NV", F_IF)              # LO ± IF = 2.87 GHz
            play("cw", "NV", duration=mw_cw_len)      # NV RF ON (겹치기)

            wait(laser_wait_time, "AOM1", "SPCM1")

            # 5) Laser On before measurement
            play("laser_ON", "AOM1", duration=laser_cycle)
            wait(count_wait_time, "SPCM1")

            # 6) Photon counting integration
            with for_(n, 0, n < n_count, n + 1):
                measure("readout", "SPCM1",
                        time_tagging.analog(times, single_integration_time_ns, counts))
                assign(total_counts, total_counts + counts)

            # 7) Save result for this pixel
            save(total_counts, counts_st)
            # 8) Reset accumulator
            assign(total_counts, 0)

            # 다음 픽셀 전 동기화(권장)
            align("NV", "AOM1", "SPCM1")

        # 9) x ramp to zero voltage
        ramp_to_zero("mirror_x", duration=galvo_ramp_time * 12)

    # 10) y ramp to zero voltage
    ramp_to_zero("mirror_y", duration=galvo_ramp_time * 12)

    with stream_processing():
        counts_st.buffer(pixel_x * pixel_y).save("counts_array")

#%%

#####################################
#  Open Communication with the QOP  #
#####################################
qmm = QuantumMachinesManager(host=qop_ip, port=qop_port)

###########################
# Run or Simulate Program #
###########################

# Spyder에서 새창을 띄우고 싶으면 qt, Plots 패널이면 inline 사용
try:
    get_ipython().run_line_magic('matplotlib', 'qt')
except Exception:
    pass

now = datetime.datetime.now()
formattedDate = now.strftime("%Y%m%d_%H%M%S")

if simulate:
    simul_duration = 100 * u.us // 4
    simulation_config = SimulationConfig(duration=simul_duration)  # In clock cycles = 4ns
    job = qmm.simulate(config, raster_scan, simulation_config)
    samples = job.get_simulated_samples()

    fig, ax = plt.subplots()
    ax.plot(samples.con1.analog["3"], '-', linewidth=2, label="Galvo_x 3(x)")
    ax.plot(samples.con1.analog["4"], '-', linewidth=2, label="Galvo_y 4(y)")
    ax.plot(samples.con1.digital["7"], linewidth=1, label="AOM 7")  # AOM timing
    plt.grid(':', color='0.5', linewidth=0.1)
    ax.set_ylim(-0.2, 0.2)
    ax.legend()
    ax.set_xlabel("Time [ns]")
    ax.set_ylabel("Output")

elif plot:
    qm = qmm.open_qm(config)
    job = qm.execute(raster_scan)

    res_handles = job.result_handles
    res_handles.wait_for_all_values()

    counts_array = res_handles.get("counts_array").fetch_all()
    counts_per_second = counts_array / integration_time_sec

    counts_2d = counts_per_second.reshape((pixel_y, pixel_x))

    voltage_range_x = np.linspace(mirror_amp, -mirror_amp, pixel_x, endpoint=True)
    voltage_range_y = np.linspace(mirror_amp, -mirror_amp, pixel_y, endpoint=True)

    df = pd.DataFrame(counts_2d, index=voltage_range_y, columns=voltage_range_x)
    df.index.name = "Voltage Y / Voltage X"

    output_file = f"{formattedDate}_pixel_x_{pixel_x}_pixel_y_{pixel_y}_with_RF_2p87GHz.csv"
    df.to_csv(output_file)

    def format_coord(x, y):
        return f"x={x:.2f}, y={y:.2f}"

    fig, ax = plt.subplots(figsize=(8, 5))
    interrupt_on_close(fig, job)  # Interrupts the job when closing the figure

    image = ax.imshow(
        counts_2d,
        extent=[mirror_amp, -mirror_amp, mirror_amp, -mirror_amp],
        origin="lower",
        aspect='auto',
        cmap='viridis',
        vmin=float(min(counts_per_second)),
        vmax=float(max(counts_per_second)),
    )
    ax.format_coord = format_coord
    ax.set_xlabel("X Voltage (V)")
    ax.set_ylabel("Y Voltage (V)")
    ax.set_title(f"{formattedDate} With RF @ 2.87 GHz")

    cbar = plt.colorbar(image, ax=ax, label="Photon Counts/s")

    # Spyder Plots 패널로 전환하고 싶다면:
    try:
        plt.pause(5)
        get_ipython().run_line_magic('matplotlib', 'inline')
    except Exception:
        pass

    plt.show()

elif test:
    qm = qmm.open_qm(config)
    job = qm.execute(raster_scan)
    # job.halt()
