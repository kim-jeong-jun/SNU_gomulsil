# -*- coding: utf-8 -*-
"""
Created on Fri Sep 12 18:54:10 2025

@author: user
"""

"""
Raster_scan_want_CHJ
"""

import datetime
import time
from qm import SimulationConfig, LoopbackInterface
from qm.qua import *
from qm import QuantumMachinesManager
from configuration_scan_want_CHJ import *
import matplotlib.pyplot as plt
import pandas as pd

#%%
################### 
# The QUA program #
###################

plot = True
test = False



# #############################################################
# # simulation parameters
# ##############################################################
# total_integration_time = int(10 * u.us) // 4 # Total duration of the measurement
# single_integration_time_ns = int(5* u.us) // 4  # 500us # Duration of a single chunk. Needed because the OPX cannot measure for more than ~1ms
# single_integration_time_cycles = single_integration_time_ns // 4
# n_count = int(total_integration_time / single_integration_time_ns) # Number of chunks to get the total measurement time
# count_wait_time = 5 * u.us // 4
# ### 기존 1 ms -> 10 us 로 변경 ###

# integration_time_sec = total_integration_time * 1e-9 * 4
# laser_cycle = total_integration_time*1.1
# laser_wait_time = count_wait_time



# ### Galvo Scan parameters ###

# pixel_x = 3 #default 321
# pixel_y = 3 #default 321
# # 우리가 원하는 픽셀값

# x_want = - 0.1
# y_want = - 0.1
# # 우리가 원하는 시작점
# # 계수 입력이 -0.3 넘어가면 안 됨.
# # 갈보미러에 인가된 전압이 없을 때를 (0,0)으로 가정함.
# # 해당 코드는 상기 언급한 (0,0)을 기준으로한 상대적 좌표값으로의 이동임.
# # Ex) mirror_amp = -0.1이면, (-0.1,-0.1)로 이동 됨.
# # 따라서 x_want, y_want를 임의의 값으로 변경하여 시작점을 설정할 수 있음.

# x_add = 2 * (- x_want)
# y_add = 2 * (- y_want)
# # 우리가 원하는 스캔범위
# # 상기 설정한 시작점을 기준으로 임의의 스캔 범위를 설정할 수 있음.
# # 쉽게 말하면, 기준점으로부터 얼만큼 더할 것인가?
# # 현재는 2 * (- x_want) 형태로 설정하여 시작점과 원점을 기준으로 정사각형을 형태로 스캔되도록 설정해둠.
# # 이 값을 조절하여 임의의 스캔 형태로 변경할 수 있음.
# # Ex) (0,0) -> (-0.1,-0.1) 이동 -> (0.1,0.1)까지 이동

# # 최종적으로 임의의 스캔 범위를 설정할 수 있도록 코드를 작성해둠.
# # 이는 우리가 원하는 NV 좌표를 소수점 아래 3자리 이하로 정밀하게 탐색할 수 있도록 하기 위함임.
# # 이를 위해서는 Pixel을 300이상의 고해상도 스캔이 필요한데, 이 과정에서 스캔 범위를 최대한으로 줄여 시간을 줄이기 위해서 작성됨.
# # 가능하다면 얻은 스캔이미지를 기반으로 NV 추정 위치를 소수점 아래 3자리 이하로 정밀하게 얻을 수 있는 코드도 작성해보면 좋을듯 함.

# #plot parameters
# x_start = x_want
# x_end = x_want + x_add
# y_start = y_want
# y_end = y_want + y_add
# # 실험결과가 Plot될 때 update를 위한 parameters

# ### Galvo mirror parameters ###
# galvo_ramp_time = 1_000 * u.ns // 4 # 1ms
# # 이는 갈보미러가 돌아가는 시간으로 거울이 깨지지 않도록 하기 위해 길게 설정해둠.
# # simulation을 수행할 때는 이 값을 simulation duration을 고려하여 줄여서 설정해도 됨.

# galvo_x_time = 1 *u.us // 4 + total_integration_time + 2 * count_wait_time
# galvo_y_time = galvo_ramp_time + (galvo_x_time * (pixel_x + 1))
## galvo_time 작성해둔 odmr scan code 참고하여 간단하게 고치는 것 추천함.
## 기존 2025-1 고물실 code 유지하였으나, 이로 인하여 시뮬레이션이나 실제 실험 시에 대기 타이밍이 길어질 수 있음.
## 특히 simulation에서 1 *u.ms -> us 단위로 바꿔줘야 시간 내에 다 볼 수 있기에 바꿔둠.

# ramp_x_voltage = (x_want)/(galvo_ramp_time*4) 
# ramp_y_voltage = (y_want)/(galvo_ramp_time*4) 
# # x 방향으로 x_want 만큼 이동
# # y 방향으로 y_want 만큼 이동

# voltage_x_add = ( x_add) / ((pixel_x-1))
# voltage_y_add = ( y_add) / ((pixel_y-1))
# # x 방향으로 x_add 만큼 scan
# # y 방향으로 y_add 만큼 scan







#############################################################
# counter parameters
##############################################################

total_integration_time = int(1000 * u.us) // 4 # Total duration of the measurement
single_integration_time_ns = int(500* u.us) // 4  # 500us # Duration of a single chunk. Needed because the OPX cannot measure for more than ~1ms
single_integration_time_cycles = single_integration_time_ns // 4
n_count = int(total_integration_time / single_integration_time_ns) # Number of chunks to get the total measurement time
count_wait_time = 500 * u.us // 4

integration_time_sec = total_integration_time * 1e-9 * 4
laser_cycle = total_integration_time*1.1
laser_wait_time = count_wait_time



### Galvo Scan parameters ###

pixel_x = 51 #default 321
pixel_y = 51 #default 321
# 우리가 원하는 픽셀값

x_want = - 0.1
y_want = - 0.1
# 우리가 원하는 시작점
# 계수 입력이 -0.3 넘어가면 안 됨.
# 갈보미러에 인가된 전압이 없을 때를 (0,0)으로 가정함.
# 해당 코드는 상기 언급한 (0,0)을 기준으로한 상대적 좌표값으로의 이동임.
# Ex) mirror_amp = -0.1이면, (-0.1,-0.1)로 이동 됨.
# 따라서 x_want, y_want를 임의의 값으로 변경하여 시작점을 설정할 수 있음.

x_add = 2 * (- x_want)
y_add = 2 * (- y_want)
# 우리가 원하는 스캔범위
# 상기 설정한 시작점을 기준으로 임의의 스캔 범위를 설정할 수 있음.
# 쉽게 말하면, 기준점으로부터 얼만큼 더할 것인가?
# 현재는 2 * (- x_want) 형태로 설정하여 시작점과 원점을 기준으로 정사각형을 형태로 스캔되도록 설정해둠.
# 이 값을 조절하여 임의의 스캔 형태로 변경할 수 있음.
# Ex) (0,0) -> (-0.1,-0.1) 이동 -> (0.1,0.1)까지 이동

# 최종적으로 임의의 스캔 범위를 설정할 수 있도록 코드를 작성해둠.
# 이는 우리가 원하는 NV 좌표를 소수점 아래 3자리 이하로 정밀하게 탐색할 수 있도록 하기 위함임.
# 이를 위해서는 Pixel을 300이상의 고해상도 스캔이 필요한데, 이 과정에서 스캔 범위를 최대한으로 줄여 시간을 줄이기 위해서 작성됨.
# 가능하다면 얻은 스캔이미지를 기반으로 NV 추정 위치를 소수점 아래 3자리 이하로 정밀하게 얻을 수 있는 코드도 작성해보면 좋을듯 함.

#plot parameters
x_start = x_want
x_end = x_want + x_add
y_start = y_want
y_end = y_want + y_add
# 실험결과가 Plot될 때 update를 위한 parameters



### Galvo mirror parameters ###

galvo_ramp_time = 1_000_000 * u.ns // 4 # 1ms
# 이는 갈보미러가 돌아가는 시간으로 거울이 깨지지 않도록 하기 위해 길게 설정해둠.
# simulation을 수행할 때는 이 값을 simulation duration을 고려하여 줄여서 설정해도 됨.

galvo_x_time = 1 *u.ms // 4 + total_integration_time + 2 * count_wait_time
galvo_y_time = galvo_ramp_time + (galvo_x_time * (pixel_x + 1))
single_galvo_y_time = galvo_y_time

ramp_x_voltage = (x_want)/(galvo_ramp_time*4) 
ramp_y_voltage = (y_want)/(galvo_ramp_time*4) 
# x 방향으로 x_want 만큼 이동
# y 방향으로 y_want 만큼 이동

voltage_x_add = ( x_add) / ((pixel_x-1))
voltage_y_add = ( y_add) / ((pixel_y-1))
# x 방향으로 x_add 만큼 scan
# y 방향으로 y_add 만큼 scan




############################################################

##### end of parameters #####
#############################

with program() as raster_scan:  
    
    v_x = declare(fixed)
    v_y = declare(fixed)
    
    times = declare(int, size=1000)  # QUA vector for storing the time-tags
    counts = declare(int)  # variable for number of counts of a single chunk
    total_counts = declare(int)  # variable for the total number of counts
    n = declare(int)  # number of iterations
    counts_st = declare_stream()  # stream for counts
    counts_array = declare(int, size = pixel_x * pixel_y) # counts array for a heatmap
    
    a = declare(int)
    b = declare(int)
    c = declare(int) 
    
    n_y = declare(int)
    n_x = declare(int)
    y = declare(int)


        
    with for_(a, 0, a < 6, a+1):
        play(ramp(ramp_y_voltage/6), "mirror_y", duration = galvo_ramp_time+(a*0))              # 1. y ramp to mirror_amp

    with for_(n_y, 0, n_y < pixel_y , n_y + 1):                                                 # 2. set and keep y voltage during x scan cycle(galvo_y_time)        
        with if_(n_y == 0):                                                                     
            wait(galvo_y_time+(n_y*0), "mirror_y")                                                  # if 1st: keep 1st y voltage
        with else_():
            play(amp(voltage_y_add) * "ref", "mirror_y", duration = galvo_y_time+(n_y*0))         # else: add y voltage step and keep it
        # 원래는 'ref' 대신에 'const' 사용중이었음.
        # 임의의 좌표로의 이동과 스캔을 위해 mirror_x, y에 'ref' 기능 추가
        # mirror element -> 'ref' -> 'ref_pulse_single' -> ... 따라가보면 코드 쉽게 이해 가능함.
        
        with for_(b, 0, b < 6, b+1):
            play(ramp(ramp_x_voltage/6), "mirror_x", duration = galvo_ramp_time+(b*0))          # 3. x ramp to mirror_amp after set y voltage

        with for_(n_x, 0, n_x < pixel_x, n_x + 1):                                              # 4. set and keep x voltage during measure cycle(galvo_x_time)
            with if_(n_x == 0):
                wait(galvo_x_time+(n_x*0), "mirror_x")                                              # if 1st: keep 1st x voltage
            with else_():
                play(amp(voltage_x_add) * "ref", "mirror_x", duration = galvo_x_time+(n_x*0))     # else: add x voltage step and keep it
                
            wait(laser_wait_time, "AOM", "SPCM1")

            play("laser_ON", "AOM", duration=laser_cycle)  # 5. Laser On before measurement
            wait(count_wait_time, "SPCM1")

            with for_(n, 0, n < n_count, n + 1):                                                # 6. measurement
                measure("readout", "SPCM1",time_tagging.analog(times, single_integration_time_ns, counts))
                assign(total_counts, total_counts + counts)
                                
            save(total_counts, counts_st)                                                       # 7. save photon counts result for a pixel as stream
            assign(total_counts, 0)                                                             # 8. reset result to zero to prepare next measurement
            
        ramp_to_zero("mirror_x", duration = galvo_ramp_time*12)                                 # 9. x ramp to zero voltage                             
                
    ramp_to_zero("mirror_y", duration = galvo_ramp_time*12)                                     # 10. y ramp to zero voltage
    
    
    with stream_processing(): 
        counts_st.buffer(pixel_x*pixel_y).save("counts_array")
            

#%%
        
#####################################
#  Open Communication with the QOP  #
#####################################
qmm = QuantumMachinesManager(host=qop_ip, port=qop_port)

###########################
# Run or Simulate Program #
###########################



simulate = True
get_ipython().run_line_magic('matplotlib', 'qt')

now = datetime.datetime.now()
formattedDate = now.strftime("%Y%m%d_%H%M%S")

if simulate:
    simul_duration = 200 * u.us // 4
    # Simulates the QUA program for the specified duration
    simulation_config = SimulationConfig(duration=simul_duration)  # In clock cycles = 4ns
    # Simulate blocks python until the simulation is done
    job = qmm.simulate(config, raster_scan, simulation_config)
    # Get the simulated samples
    samples = job.get_simulated_samples()
    # Plot the simulated samples
    fig, ax = plt.subplots()
    ax.plot(samples.con1.analog["3"], '-', linewidth=2 ,label="Galvo_x 3(x)")
    ax.plot(samples.con1.analog["4"], '-', linewidth=2 ,label="Galvo_y 4(y)")
    plt.grid(':', color = '0.5', linewidth=0.1)
    ax.plot(samples.con1.digital["5"], linewidth=2, label="SPCM 5") # SPCM timing
    ax.plot(samples.con1.digital["7"], linewidth=1, label="AOM 7") # AOM timing
    ax.set_ylim(-0.35, 1.1)
    ax.legend()
    ax.set_xlabel("Time [ns]")
    ax.set_ylabel("Output")

elif plot:
    qm = qmm.open_qm(config)
    job = qm.execute(raster_scan)
    
    res_handles = job.result_handles
    res_handles.wait_for_all_values()
    
    counts_array = res_handles.get("counts_array").fetch_all()
    counts_per_second = counts_array / integration_time_sec
    counts_2d = counts_per_second.reshape((pixel_y, pixel_x)) 
    
    voltage_range_x = np.linspace(mirror_amp, -mirror_amp, pixel_x, endpoint=True)
    voltage_range_y = np.linspace(mirror_amp, -mirror_amp, pixel_y, endpoint=True)
    
    df = pd.DataFrame(counts_2d, index=voltage_range_y, columns=voltage_range_x)
    df.index.name = "Voltage Y / Voltage X"
    
    output_file = f"{formattedDate}_pixel_x_{pixel_x}_pixel_y_{pixel_y}_no_RF.csv"
    
        
    df.to_csv(output_file)
    
    
    
    def format_coord(x, y):
        # x and y are in axes (data) coordinates
        return f"x={x:.2f}, y={y:.2f}"


    fig, ax = plt.subplots(figsize=(8,5))
    interrupt_on_close(fig, job)  # Interrupts the job when closing the figure
    
    image = ax.imshow(counts_2d,
                  extent=[x_start, x_end, y_start, y_end],origin="lower",
                  aspect='auto', cmap='viridis', vmin=min(counts_per_second), vmax=max(counts_per_second)) # 250611 데이터 범위 counts_array->counts_per_second 반영
    
    ax.format_coord = format_coord
    ax.set_xlabel("X Voltage (V)")
    ax.set_ylabel("Y Voltage (V)")  
    ax.set_title(f'{formattedDate} Without RF')

    cbar = plt.colorbar(image, ax=ax, label="Photon Counts/s")
    
    plt.pause(3) # 5
    get_ipython().run_line_magic('matplotlib', 'inline')    
    plt.show() 

 
elif test:
    qm = qmm.open_qm(config)
    job = qm.execute(raster_scan)

    # job = qm.execute(hello_QUA)


    # job.halt()
